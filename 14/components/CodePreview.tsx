import React from 'react';
import { SpriteResult } from '../types';

interface CodePreviewProps {
  result: SpriteResult;
}

const CodePreview: React.FC<CodePreviewProps> = ({ result }) => {
  const generateCode = () => {
    const formatMatrix = (matrix: string[][]) => {
      let output = `[\n`;
      matrix.forEach(row => {
        output += `      [${row.map(c => `"${c}"`).join(', ')}],\n`;
      });
      output += `    ]`;
      return output;
    };

    return `/**
 * Generated Sprite Asset
 * Archetype: ${result.type}
 * Dimensions: ${result.dimensions.width}x${result.dimensions.height}
 * Generated by Pixel Sprite Forge (Algorithmic)
 * 
 * IMPORTANT: This sprite uses transparency. No background color is required.
 * Transparent pixels are represented as the string "transparent".
 */

export const SPRITE_DATA = {
  type: '${result.type}',
  width: ${result.dimensions.width},
  height: ${result.dimensions.height},
  palette: ${JSON.stringify(result.palette)},
  frames: {
    front: ${formatMatrix(result.matrix.front)},
    back: ${formatMatrix(result.matrix.back)},
    left: ${formatMatrix(result.matrix.left)},
    right: ${formatMatrix(result.matrix.right)}
  }
};

/**
 * Drop-in renderer example (transparency-aware, no background needed):
 * 
 * function renderSprite(ctx, x, y, facing, scale) {
 *   const matrix = SPRITE_DATA.frames[facing]; // 'front', 'back', 'left', 'right'
 *   if (!matrix) return;
 *   
 *   // Only draw non-transparent pixels - no background color needed!
 *   matrix.forEach((row, py) => {
 *     row.forEach((color, px) => {
 *       // Skip transparent pixels - they remain transparent
 *       if (color && color !== 'transparent' && color !== '#00000000') {
 *         ctx.fillStyle = color;
 *         ctx.fillRect(x + (px * scale), y + (py * scale), scale, scale);
 *       }
 *     });
 *   });
 *   
 *   // Optional: Shadow (also uses transparency)
 *   ctx.fillStyle = 'rgba(0,0,0,0.3)';
 *   ctx.fillRect(
 *     x + scale, 
 *     y + (SPRITE_DATA.height * scale) - scale, 
 *     (matrix[0].length * scale) - (2 * scale), 
 *     scale
 *   );
 * }
 * 
 * Usage:
 *   const canvas = document.getElementById('myCanvas');
 *   const ctx = canvas.getContext('2d');
 *   // No need to set a background - transparency is preserved!
 *   renderSprite(ctx, 100, 100, 'front', 4);
 */
`;
  };

  const code = generateCode();

  const handleCopy = () => {
    navigator.clipboard.writeText(code);
  };

  return (
    <div className="w-full bg-neutral-950 rounded-2xl overflow-hidden border border-neutral-800 mt-0 shadow-sm">
      <div className="flex justify-between items-center px-5 py-3 bg-neutral-900 border-b border-neutral-800">
        <span className="text-sm text-neutral-400">spriteData.js</span>
        <button
          onClick={handleCopy}
          className="text-xs bg-emerald-600 hover:bg-emerald-500 text-white font-medium px-4 py-1.5 rounded-full transition-colors"
        >
          Copy Code
        </button>
      </div>
      <pre className="p-5 overflow-auto max-h-[400px] text-xs font-mono text-emerald-400 leading-relaxed whitespace-pre scrollbar-thin">
        {code}
      </pre>
    </div>
  );
};

export default CodePreview;